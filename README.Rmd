---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "README-"
)
```

# bohemia: The R package of the Bohemia project

This package contains utilities used by the Bohemia research team. It is publicly available for the purposes of reproducibility and transparency.

## Installation

To install this package, run the below from within the R console.


```r
if(!require(devtools)) install.packages("devtools")
install_github('databrew/bohemia')
```


```{r setup, include=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      fig.width = 4,
                      fig.height = 4)
library(dplyr)
library(tidyr)
library(ggplot2)
library(bohemia)

# knitr::knit_hooks$set(
#    error = function(x, options) {
#      paste('\n\n<div class="alert alert-danger">',
#            gsub('##', '\n', gsub('^##\ Error', '**Error**', x)),
#            '</div>', sep = '\n')
#    },
#    warning = function(x, options) {
#      paste('\n\n<div class="alert alert-warning">',
#            gsub('##', '\n', gsub('^##\ Warning:', '**Warning**', x)),
#            '</div>', sep = '\n')
#    },
#    message = function(x, options) {
#      paste('\n\n<div class="alert alert-info">',
#            gsub('##', '\n', x),
#            '</div>', sep = '\n')
#    }
# )
```



## Building the package

Having done the above, run `Rscript build_package.R` from within the main directory to compile the package.

## Package utilities

This package contains several noteworthy tools.

### Generating fake data

Some methods and analysis require "dummy" data in order to be tested. Functions which generate dummy data begin with the prefix `generate_fake`. For example, `generate_fake_locations` creates a dataframe of `n` locations, grouped into `n_clusters` clusters, which is useful for testing algorithms related to clustering, buferring, etc.

Here is a working example:

```{r}
set.seed(1)
library(tidyverse)
library(sp)
library(bohemia)
# Generate some fake data
fake <- generate_fake_locations(n = 1000,
                                n_clusters = 10,
                                sd = 0.04)
# Plot the fake data
plot(fake$x, fake$y, col = rainbow(10)[fake$cluster])
```

```{r}
# Generate boundaries from the point locations
boundaries <- bohemia::create_borders(df = fake)
# Plot the boundaries
cols <- rainbow(10)[fake$cluster]
plot(fake$x, fake$y, col = cols, pch = 16, cex = 0.5)
plot(boundaries, add = T, col = adjustcolor(cols, alpha.f = 0.3))
```

```{r}
# Generate buffers from boundaries
buffers <- bohemia::create_buffers(shp = boundaries,
                                   meters = 5000)
plot(fake$x, fake$y, col = cols, pch = 16, cex = 0.5)
plot(boundaries, add = T, col = adjustcolor(cols, alpha.f = 0.3))
plot(buffers, add = T)
```

As an alternative to the above approach, and so as to generate generealizable boundaries with no "holes", we can use voronoi tesselation as opposed to convex hulling.

```{r}
boundaries <- create_borders(df = fake, voronoi = TRUE)
# Plot the boundaries
plot(fake$x, fake$y, col = cols, pch = 16, cex = 0.5)
plot(boundaries, add = T, col = adjustcolor(cols, alpha.f = 0.3))
```

Just like with convex hull generated borders, we can add buffers to delauney triangles.

```{r}
# Generate buffers from boundaries
buffers <- bohemia::create_buffers(shp = boundaries,
                                   meters = 5000)
plot(fake$x, fake$y, col = cols, pch = 16, cex = 0.5)
plot(boundaries, add = T, col = adjustcolor(cols, alpha.f = 0.3))
plot(buffers, add = T, col = adjustcolor(cols, alpha.f = 0.3))
```

In the above, we use _external_ boundaries, which results in one areas borders bleeding into the core of another area. As an alternative to this, we can use _internal_ boundaries.

```{r}
# Generate buffers from boundaries
buffers <- bohemia::create_buffers(shp = boundaries,
                                   meters = -5000)
plot(fake$x, fake$y, col = 'white', pch = 16, cex = 0.5)
plot(boundaries, add = T, col = adjustcolor(cols, alpha.f = 0.3))
plot(buffers, add = T, col = adjustcolor(cols, alpha.f = 0.5))
points(fake$x, fake$y, col = cols, pch = 16, cex = 0.5)
```

For the purposes of an intervention in which each area is assigned status A or B (ie, intervention or control), the need for buffers between areas of identical intervention status is redundant (and can unecessarily eliminate potential study participants).


```{r}
# Define some ids 
ids <- sample(1:2, nrow(boundaries), replace = TRUE)
cols2 <- c('lightblue', 'orange')
cols <- cols2[ids]

# Generate buffers from boundaries
buffers <- create_buffers(shp = boundaries,
                                   meters = -5000,
                                   ids = ids)
plot(fake$x, fake$y, col = 'white', pch = 16, cex = 0.5)
# plot(boundaries, add = T, col = adjustcolor(cols, alpha.f = 0.8))
plot(buffers, add = T, col = adjustcolor(cols2, alpha.f = 0.5))
points(fake$x, fake$y, col = cols, pch = 16, cex = 0.5)
```