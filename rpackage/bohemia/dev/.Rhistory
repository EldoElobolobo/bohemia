#       temp_data <- as.data.frame(temp_data[, !grepl('Total', colnames(temp_data))], stringsAsFactors = F)
#
#
#       temp_total <- temp_data %>%
#         dplyr::select(Geography, `Age groups (5)`, `Sex (3)`, `Place of birth`, `Visible minorit`)
#       keep <- apply(temp_total, 1, function(x){any(grepl('Total', x))})
#
#       temp_total <- temp_total[keep,]
#
#       # remove any row that has total by looping through columns
#       remove_total <- function(data_frame) {
#         # get an indicator for column name
#         variable_names <- as.character(colnames(data_frame))[1:5]
#         # loop through variables and remove rows with 'Total'
#         for(v in variable_names) {
#           data_frame <- data_frame[!grepl('Total', data_frame[, v]),]
#           print(v)
#         }
#         return(data_frame)
#       }
#
#       # remove total from all rows
#       temp_data <- remove_total(temp_data)
#
#       # Make long
#       temp_data_long <- tidyr::gather(temp_data,
#                                       key,
#                                       value,
#                                       `Never married (single) 15 years and over`:`Living in band housing`)
#
#       # Clean up names
#       names(temp_data_long) <- c('geo',
#                                  'age',
#                                  'sex',
#                                  'pob',
#                                  'vm',
#                                  'geo_code',
#                                  'special_indicators',
#                                  'value')
#
#       # temp_11 <- temp_no_
#       # recode sex
#       temp_data_long$sex <- gsub('Females', 'Female', temp_data_long$sex)
#       temp_data_long$sex <- gsub('Males', 'Male', temp_data_long$sex)
#
#       # recod pob
#       temp_data_long$pob <- gsub('birth', 'Birth', temp_data_long$pob)
#       temp_data_long$pob <- gsub('inside', 'in', temp_data_long$pob)
#
#       # Clean up sex
#       temp_data_long$sex <- ifelse(temp_data_long$sex == 'Total - Sex', 'Total', temp_data_long$sex)
#
#       # Clean up pob
#       temp_data_long$pob <-
#         ifelse(temp_data_long$pob == 'Total - Place of Birth', 'Total', temp_data_long$pob)
#
#       # Add year
#       temp_data_long$year <- as.numeric(substr(name, 1, 4))
#
#       # Remove duplicate columns
#       temp_data_long <- temp_data_long[,!duplicated(names(temp_data_long))]
#       temp_data_long <- temp_data_long[,!is.na(names(temp_data_long))]
#
#       # Clean up age group
#       temp_data_long$age <-
#         ifelse(temp_data_long$age == '15 to 2', '15 to 24 years',
#                ifelse(temp_data_long$age == 'Total - 15 years and over', '15 +',
#                       ifelse(temp_data_long$age == 'Total - 15 year', '15 +',
#                              temp_data_long$age)))
#
#     }
#     data_list[[name]] <- temp_data_long
#   } else {
#     # get the survey folder names in data
#     path_to_data <- 'data/survey_data'
#     var_summary <- read_csv(paste0(path_to_data, '/var_summary.csv'))
#     var_names <- as.character(var_summary$long_name)
#     survey_folders <- list.files(path_to_data)
#     # remove var_summary.csv from the list so that there are 10 unique folders pertaining to each survey
#     survey_folders <- survey_folders[!grepl('var_summary', survey_folders)]
#     # create list to store results
#     result_list <- list()
#     # loop through each folder and read in all data in that folder (either 1 or 3)
#     for(i in 1:length(survey_folders)) {
#       temp_folder <- survey_folders[i]
#       survey_data <- list.files(paste(path_to_data, temp_folder, sep = '/'))
#       data_list <- list()
#       for(j in 1:length(survey_data)) {
#         temp_data <- survey_data[j]
#         if (grepl('.sav', temp_data)) {
#           temp_dat <- read.spss(file = paste(path_to_data,
#                                              temp_folder,
#                                              temp_data, sep = '/'),
#                                 use.value.labels = T,
#                                 to.data.frame = T,
#                                 trim.factor.names = T,
#                                 trim_values = F,
#                                 use.missings = T)
#
#           if(grepl('gss|piaac|cfcs|sduhs', temp_data)) {
#             get_year = T
#           } else {
#             get_year = F
#           }
#
#           # get long for variable names
#           colnames(temp_dat) <- attr(temp_dat,"variable.labels")
#           # get the column names we want from are varibale list
#           temp_sub <-  temp_dat[, colnames(temp_dat)[colnames(temp_dat) %in% var_names]]
#           temp_sub <- clean_subset_survey(temp_sub, get_year = get_year, folder = temp_folder)
#           data_list[[j]] <- as.data.frame(temp_sub)
#         }
#       }
#
#       if(length(data_list) > 1) {
#
#         list_length = length(data_list)
#
#         if(list_length == 2) {
#           temp_1 <- data_list[[1]]
#           temp_2 <- data_list[[2]]
#           # make colnames the same and join
#           join_key <- Reduce(intersect, list(colnames(temp_1),
#                                              colnames(temp_2)))[1]
#           # outer join temp1 and temp2
#           data_frame <- full_join(temp_1, temp_2, by = join_key)
#           result_list[[i]] <- data_frame
#         } else {
#           temp_1 <- data_list[[1]]
#           temp_2 <- data_list[[2]]
#           temp_3 <- data_list[[3]]
#           # make colnames the same and join
#           join_key <- Reduce(intersect, list(colnames(temp_1),
#                                              colnames(temp_2),
#                                              colnames(temp_3)))[1]
#           # outer join temp1 and temp2
#           temp <- full_join(temp_1, temp_2, by = join_key)
#           data_frame <- full_join(temp, temp_3, by = join_key)
#           result_list[[i]] <- data_frame
#         }
#
#       } else {
#         result_list[[i]] <- data_list
#       }
#       print(temp_folder)
#     }
#     length(result_list)
#   }
#
#   if(data_type == 'census'){
#     dat <- bind_rows(data_list)
#     return(dat)
#   } else {
#     return(result_list)
#   }
# }
# Get surey and census data
# If the aggregated/cleaned file already exists (ie, this script has already been run)
# load it
# CURRENTLY COMMENTING OUT IN ORDER TO SPEED UP
# if('survey_list.rda' %in% dir('data')) {
#   survey_list <- readRDS('data/survey_list.rda')
# } else {
#   survey_list <- get_data(data_type = 'survey')
#   saveRDS(survey_list, 'data/survey_list.rda')
# }
# read in dictionary
census_dict <- read_csv('dictionaries/census_dictionary.csv')
if('census.feather' %in% dir('data')){
census <- read_feather('data/census.feather')
} else {
census <- get_census_data()
# and then save data to to "data" folder for faster retrieval in subsequent runs
# save(census, file = 'data/census.RData')
write_feather(census, 'data/census.feather')
}
# define input cateogry choices
category_choices <- sort(unique(census_dict$category))
category_choices <- category_choices[!category_choices %in% c('demographic', 'geo_code', 'year')]
names(category_choices) <- Hmisc::capitalize(category_choices)
head_vector <- c('Geography', 'geo_code', 'year', 'Age group', 'Sex', 'Place of Birth','Visible minority', 'Aboriginal identity', 'Total')
# Eliminate everywhere references to 15 and over
names(census) <- gsub(' 15 and over', '', names(census))
names(census) <- gsub(' 15 years and over', '', names(census))
census_dict$variable <- names(census)
# Make a theme dictionary
theme_dictionary <-
data_frame(long_name = c('Supportive families',
'Education',
'Employment',
'Civic engagement',
'Diversity',
'Communities',
'Health and wellness'),
short_name = c('sf',
'ed',
'em',
'ce',
'ds',
'cc',
'hw'))
# Make a dictionary to associate data set names in the survey list
# with the code in the var_summary
dataset_dictionary <-
data_frame(short_name = c('cfc',
'eic',
'gss10',
'gss11',
'gss12',
'gss13',
'gss14',
'lfs',
'osduhs',
'pisa'),
long_name = c('2014_cananda_financial_capabilities_survey',
'2014_employment_insurance_coverage_survey',
'2010_general_social_survey',
'2011_general_social_survey',
'2012_general_social_survey',
'2013_general_social_survey',
'2014_general_social_survey',
'1987_2015_labour_force_survey',
'2015_ontario_student_drug_use_and_health_survey',
'2012_program_for_international_assessment_of_adult_comptencies'))
# Clean up the var_summary (survey_dict) to make more usable
survey_dictionary <-
var_summary %>%
mutate(data_set = unlist(lapply(strsplit(new_variable, '_'), function(x) x[2]))) %>%
mutate(theme_name = unlist(lapply(strsplit(new_variable, '_'), function(x) x[1]))) %>%
mutate(display_name = Hmisc::capitalize(gsub('_', ' ', variable_name))) %>%
dplyr::rename(short_name = data_set) %>%
left_join(dataset_dictionary, by = 'short_name') %>%
mutate(display_name = paste0(display_name,
' (',
gsub('_', ' ', long_name),
')'))
# Choices for survey download
survey_download_choices <- names(survey)
names(survey_download_choices) <- Hmisc::capitalize(gsub('_', ' ', survey_download_choices))
# Read in genderrace dictionary
race_gender_dictionary <- read_csv('dictionaries/race_gender_dictionary.csv')
race_gender_dictionary <-
race_gender_dictionary %>%
mutate(variable_name = ifelse(variable_name == 'na', NA, variable_name))
# Loop through each survey dataset and add a race / gender var
for(i in 1:nrow(race_gender_dictionary)){
this_variable <- race_gender_dictionary$variable_name[i]
if(!is.na(this_variable)){
this_data_name <- race_gender_dictionary$data_folder[i]
this_category <- race_gender_dictionary$category[i]
this_data <- survey[[which(names(survey) == this_data_name)]]
if(!this_category %in% names(this_data)){
this_data[,this_category] <- this_data[,this_variable, drop = TRUE]
survey[[which(names(survey) == this_data_name)]] <- this_data
}
}
print(i)
}
# # Perform a check to ensure that all race/gender variables are in their respective datasets
# out <- rep(NA, nrow(race_gender_dictionary))
# for(i in 1:nrow(race_gender_dictionary)){
#   this_variable <- race_gender_dictionary$variable_name[i]
#   if(!is.na(this_variable)){
#     this_data_name <- race_gender_dictionary$data_folder[i]
#     this_data <- survey[[which(names(survey) == this_data_name)]]
#     out[i] <- this_variable %in% names(this_data)
#   }
# }
# Define a list of variables from the themes
theme_variables <- survey_dictionary %>%
dplyr::select(-long_name) %>%
left_join(theme_dictionary, by = c('theme_name' = 'short_name')) %>%
filter(!grepl('demo_', new_variable),
!is.na(long_name)) %>%
.$display_name
shiny::runApp('Documents/daterange')
library(shiny)
library(DT)
library(ggplot2)
library(plotly)
library(shinydashboard)
library(shinyBS)
library(shinythemes)
library(shinyLP)
library(dplyr)
library(DT)
library(leaflet)
library(ggmap)
library(raster)
library(shiny)
library(shinydashboard)
source('global.R')
runApp('Documents/bohemia/shiny/datamanager')
runApp('Documents/bohemia/shiny/datamanager')
library(shiny)
library(shinydashboard)
library(sparkline)
library(jsonlite)
library(dplyr)
install.packages("shinythemes")
library(shinythemes)
shinyApp(
ui = fluidPage(theme = shinytheme("yeti"), server)
)
library(shinythemes)
#' @import shiny
app_ui <- function() {
tagList(
# golem_add_external_resources(
# tags$script(src="www/script.js"),
# tags$script(src="www/handlers.js"),
tags$link(rel="stylesheet", type="text/css", href="www/custom.css"),
# ),
# List the first level UI elements here
fluidPage(
h1("hefpi")
)
)
}
#' @import shiny
golem_add_external_resources <- function(){
addResourcePath(
'www', system.file('app/www', package = 'hefpi')
)
tags$head(
golem::activate_js(),
golem::favicon()
# Add here all the external resources
# If you have a custom.css in the inst/app/www
# Or for example, you can add shinyalert::useShinyalert() here
#tags$link(rel="stylesheet", type="text/css", href="www/custom.css")
)
}
#' Run the Shiny Application
#'
#' @export
#' @importFrom shiny shinyApp
#' @importFrom golem with_golem_options
run_app <- function(...) {
with_golem_options(
app = shinyApp(ui = app_ui, server = app_server),
golem_opts = list(...)
)
}
shiny::runApp('Documents/databrew/dashboard_template')
library(shiny)
library(shinydashboard)
runApp('Documents/databrew/dashboard_template')
library(shiny)
library(shinydashboard)
header <- dashboardHeader(title = tags$a(tags$img(src='logo_clear.png')))
runApp('Documents/databrew/dashboard_template')
getwd()
setwd('Documents/bohemia/rpackage/bohemia/dev/')
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
install.packages('dplyr')
install.packages('ggplot2')
install.packages('ggthemes')
install.packages('leaflet'),'lubridate','maps','sp','DT','Hmisc','extrafont','scales','rgeos','maptools','gpclib','dismo','tidyr','gsheet','readxl','RPostgreSQL','devtools','DBI','RPostgres','qrcode','readr','rmarkdown','rgdal','deldir','kableExtra','gridExtra','ggpubr','extrafont','rgeos','deldir','geosphere','htmlTable'
install.packages('leaflet')
install.packages('lubridate')
install.packages('maps')
install.packages('sp')
install.packages('sp')
install.packages('DT')
install.packages('Hmisc')
install.packages('extrafont')
install.packages('scales')
install.packages('rgeos')
install.packages(maptools')
''extrafont',''scales','rgeos','maptools','gpclib','dismo','tidyr','gsheet','readxl','RPostgreSQL','devtools','DBI','RPostgres','qrcode','readr','rmarkdown','rgdal','deldir','kableExtra','gridExtra','ggpubr','extrafont','rgeos','deldir','geosphere','htmlTable'
install.packages('maptools')
install.packages('gpclib')
install.packages('dismo')
install.packages('tidyr')
install.packages('gsheet')
install.packages('readxl')
install.packages('RPostgreSQL')
install.packages('devtools')
install.packages('DBI')
install.packages('RPostgres')
install.packages('qrcode')
install.packages(c('readr','rmarkdown','rgdal','deldir','kableExtra','gridExtra','ggpubr','extrafont','rgeos','deldir','geosphere','htmlTable'))
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
install.packages('XML')
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
install.packages('googlesheets')
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# Document and reload your package
golem::document_and_reload()
install.packages('gt')
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
q# Run the application
run_app()
install.packages('‘shinydashboard’')
install.packages('shinydashboard')
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
q# Run the application
run_app()
warnings()
install.packages('tidyverse')
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
q# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
getwd()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
